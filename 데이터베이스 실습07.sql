-- HR 조회

-- 1. 모든 사원의 이름 (FIRST_NAME,LAST_NAME)을 조회하라.
SELECT FIRST_NAME, LAST_NAME
FROM EMPLOYEES;


-- 2. 모든 사원의 모든 정보를 조회하라.
SELECT  * from EMPLOYEES;

-- 3. 모든 도시 명을 조회하라.
SELECT city
FROM LOCATIONS;

-- 4. 이름(FIRST_NAME)이 M 으로 시작하는 사원의 모든 정보를 조회하라.
SELECT *
FROM EMPLOYEES
WHERE FIRST_NAME LIKE 'M%'

-- 5. 이름(FIRST_NAME)의 두 번째 글자가 'a'인 사원의 이름(FIRST_NAME)과 연봉을 조회하라.
SELECT *
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '_a%'

-- 6. 도시 명을 오름차순 정렬하라.
SELECT DISTINCT city
FROM LOCATIONS
ORDER BY city;


-- 7. 도시 명을 오름차순 정렬하라.
SELECT department_name
FROM DEPARTMENTS
ORDER by department_name DESC;

-- 8. 얀봉이 7000 이상인 사원들의 모든 정보를 연봉순으로 정령하라.
SELECT *
FROM EMPLOYEES
WHERE salary >= 7000
ORDER BY salary;

-- 9. 인센티브(COMMISSION_PCT)를 받지 않는 사원들의 모든 정보를 조회하라.
SELECT *
FROM EMPLOYEES
WHERE commission_pct IS NULL;

-- 10. 인센티브(COMMISSION_PCT)를 받는 사원들의 모든 정보를 조회하라.
SELECT *
FROM EMPLOYEES
WHERE commission_pct IS NOT NULL;

-- 11. 2007년 06월 21일에 입사한 사원의 사원번호, 이름(FIRST_NAME, LAST_NAME) 그리고 부서번호를 조회하라.
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE HIRE_DATE ='2007-06-21';

-- 12. 2006년에 입사한 사원의 사원번호와 입사일을 조회하라.
SELECT EMPLOYEE_ID, HIRE_DATE
FROM EMPLOYEES
WHERE (HIRE_DATE BETWEEN > '2006-01-01')
		AND (HIRE_DATE <= '2006-12-31')
ORDER BY HIRE_DATE;

SELECT EMPLOYEE_ID, HIRE_DATE
FROM EMPLOYEES
WHERE (HIRE_DATE LIKE > '2006%')
ORDER BY HIRE_DATE;

-- 13. 이름(FIRST_NAME)의 길이가 5글자 이상인 사원을 조회하라.
SELECT *
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '_____%'; 

--14. 연봉이 12000 이상되는 지원들의 LAST_NAME 및 연도를 조회하라.
SELECT LAST_NAME, SALATY
FROM EMPLOYEES 
WHERE SALARY >= 12000
ORDER BY SALARY;

-- 15. 사원번호가 176 인 사람의 LAST_NAME 과 부서 번호 조회하라.
SELECT LAST_NAME, SALATY
FROM EMPLOYEES 
WHERE EMPLOYEE_ID  = 176;

-- 16. 연봉이 5000 에서 12000의 범위 이외인 사람들의 LAST_NAME 및 연봉을 조회힌다.
SELECT LAST_NAME, SALATY
FROM  EMPLOYEES
WHERE (SALARY >= 5000) AND (SALARY >= 12000)
ORDER BY SALARUY;

SELECT LAST_NAME, SALATY
FROM  EMPLOYEES
WHERE SALARY BETWEEN 5000 AND 12000
ORDER BY SALARUY;

-- 17. 2003-02-20 일부터 2005-05-01 사이에 고용된 사원들의 LAST_NAME 사번, 고용일자를 조회한다.
SELECT LAST_NAME, EMPLOOYEE_ID, HIRE_DATE
FREE EMPLOYEES
WHERE HIRE_DATE >= '2003-02-20'
AND HIRE_DATE >= '2005-05-01'
ORDER BY HIRE DATE;

FREE EMPLOYEES
WHERE HIRE_DATE >= '2003-02-20'
AND HIRE_DATE >= '2005-05-01'
ORDER BY HIRE DATE;

-- 18. 20 번 및 50 번 부서에서 근무하는 모든 사원들의 LAST_NAME 및 부서 번호를 알파벳순으로 조회한다.
SELECT LAST_NAME, EPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 20 OR DEPARTMENT_ID = 50
ORDER BY LAST_NAME;


-- 19. 20 번 및 50 번 부서에 근무하며, 연봉이 5000 ~ 12,000 사이인 사원들의 LAST_NAME 및 연봉을 조회한다.
SELECT LAST_NAME, EPARTMENT_ID, SALARY
FROM EMPLOYEES
WHERE (DEPARTMENT_ID = 20) OR (DEPARTMENT_ID = 50)
		AND (SALARY BETWEEN 5000 AND 12000)
ORDER BY SALARY

-- 20. 2007년도에 고용된 모든 사람들의 LAST_NAME 및 고용일을 조회한다.
SELECT LAST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE LIKE '2007%'
ORDER BY HIRE_DATE

-- 21. 매니저가 없는 사람들의 LAST_NAME 및 JOB_ID 를 조회한다.
SELECT LAST_NAMEM, JOB_ID
FROM EMPLOYEES
WHERE MANAGER_ID IS NOT NULL;

-- 22 매니저가 있는 사람들의 LAST_NAME 및 JOB_ID 를 조회한다.
SELECT LAST_NAMEM, JOB_ID
FROM EMPLOYEES
WHERE MANAGER_ID NOT NULL;

-- 23. 커미션을 버는 모든 사원들의 LAST_NAME, 연봉 및 커미션을 조회한다.
--    연봉 역순, 커미션 역순차로 정렬한다.
SELECT LAST_NAME, SALARY, CMMISION_PCT
FROM EMPLOYEES
WHERE COMMISSION IS NOT NULL 
ORDER BY SALARUY DESC, COMMISSION_PCT DESC;

-- 24. LAST_NAME 의 네번째 글자가 a 인 사원들의 LAST_NAME 을 조회한다.
SELECT LAST_NAME
FROM EMPLOYESS
WHERE LAST_NAME LIKE '___a%'

-- 25. LAST_NAME 에 a 및(OR) e 글자가 있는 사원들의 LAST_NAME 을 조회한다.
SELECT LAST_NAME
FROM EMPLOYESS
WHERE LAST_NAME LIKE '%a%' OR LAST_NAME LIKE %e%;

-- 26. 연봉이 2,500, 3,500, 7000 이 아니며 직업이 SA_REP 이나 ST_CLERK 인 사람들을 조회한다.
SELECT LAST_NAME,SALARY, JOB ID
FROM EMPLOYEES
WHERE (SALARY <> 2500 AND SALARY != 3500 AND SALARY <> 7000)
	AND (job_id = 'SA_REP' OR job_id = 'ST_CLERK');

SELECT LAST_NAME, SALARY, JOB_ID
FROM EMPLOYEES
WHERE SALARY IN (2500,3500,7000) AND
		job_id IN ('SA_REP','ST_CLERK');
	
-- 27. 회사 전체의 최대 연봉, 최소 연봉, 연봉 총 합
-- 및 평균 연봉을 조회하세요
-- 반올림 : ROUND (대상,자릿수)
SELECT max(SALARY) 최대연봉,
	   min(SALARY) 최소연봉,
	   sum(SALARY) 총연봉,
	   avg(SALARY) 평균연봉,
	   ROUND (avg(SALARY)) 평균연봉,
	   ROUND (avg(SALARY), 2) 평균연봉,	   
FROM EMPLOYEES;

-- 28. 각 JOB_ID 별, 최대 연봉, 최소 연봉,
 --연봉 총 합 및 평균 연봉을 정수로 포맷하여 조회하세요
SELECT max(SALARY) 최대연봉,
	   min(SALARY) 최소연봉,
	   sum(SALARY) 총연봉,
	   ROUND (avg(SALARY)) 평균연봉,
FROM EMPLOYEES
GROUP BY JOB-ID
ORDER BY JOB-ID;

-- 29. 동일한 직업을 가진 사원들의 총 수를 조회하세요
SELECT JOB_ID 직책, COUNT(JOB_ID) 사원수
FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY 사원수 DESC;

-- 30. 상사로 근무하는 사원들의 총 수를 조회하세요
SELECT COUNT(DISTINCT MANAGER_ID) 매니저수
FROM EMPLOYEES;

-- 31. 사내의 최대 연봉 및 최소 연봉의 차이를 조회하세요
SELECT MAX(SALARY) 최대연봉, MIN(SALARY) 최소연봉,
		(MAX(SALARY) - MIN(SALARY)) 연봉차이
FROM EMPLOYEES;

SELECT MAX(SALARY) 최대연봉,
		MIN(SALARY) 최소연봉,
		MAX(SALARY) - MIN(SALARY) 연봉차이
FROM EMPLOYEES;

-- 32. 매니저의 사번 및 그 매니저 밑 사원들 중 (상사와 부하직원들을 포함해서)
--최소 연봉을 받는 사원의 연봉을 조회하세요
--단, 매니저가 없는 사람들은 제외, 최소 연봉이 6000 미만인 경우는 제외
--연봉 기준 역순으로 조회하세요

-- 먼저, 상사와 사원들 조회
-- 단, 상사 자신은 조회되지 않음
-- 하지만, 최소연봉 받는 사원을 조회하는데는 문제없음
-- 상사가 최소연봉을 받을리 없으므로
SELECT MANAGER_ID, EMPLOYEE_ID, SALARY
FROM EMPLOYEES
ORDER BY MANAGER_ID;

-- 상사가 101번인 사원들의
-- 최소연봉은 6500임
SELECT MANAGER_ID, MIN(SALARY) 최소연봉
FROM EMPLOYEES
GROUP BY MANAGER_ID
ORDER BY MANAGER_ID;

-- 상사가 101번인 사원들의
-- 최소연봉은 6500임
SELECT MANAGER_ID, MIN(SALARY) 최소연봉
FROM EMPLOYEES
WHERE MANAGER_ID IS NOT NULL
GROUP BY MANAGER_ID
HAVING MIN(SALARY) 최소연봉 >= 6000
ORDER BY 최소연봉 DESC;

-- IT 부서의 급여 총합을 조회하라.
SELECT SUM(SALARY) 급여총합
FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG';

SELECT JOB_ID, SUM(SALARY) 급여총합
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING JOB_ID = 'IT_PROG';

SELECT SUM(SALARY) 급여총합
FROM EMPLOYEES e JOIN DEPARTMENTS d 
USING (DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = 'IT';

-- 부서와 직무별 최대급여, 최소급여, 사원수를 조회하라.
SELECT DEPARTMENT_ID , JOB_ID,
		 MAX(SALARY) 최대급여 ,MIN(SALARY) 최소급여, COUNT(JOB_ID) 사원수
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID;
ORDER BY DEPARTMENT_ID, JOB_ID;

--job_title이 manager인 사원들의 총 수를 조회하세요
SELECT COUNT(JOB_TITLE) manager사원수 
FROM JOBS j JOIN EMPLOYEES e 
USING (JOB_ID);
WHERE JOB_TITLE LIKE '%manager';

-- 모든 사원들의 성, 부서 이름 및 부서 번호을 조회하세요
SELECT LAST_NAME, DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES e  JOIN DEPARTMENTS d 
USING (DEPARTMENT_id);

-- 30번 부서 사원들의 모든 직업들과 부서명으로 조회하세요. 부서 또한 포함한다.
SELECT JOB_ID, DEPARTMENT_name
FROM EMPLOYEES e JOIN DEPARTMENTS d 
USING (DEPARTMENT_id)
WHERE DEPARTMENT_ID = 30;

-- 지역번호 2500 에서 근무하는 사원의 이름, 직업,부서번호,부서명을 조회하세요
SELECT FIRST_NAME , JOB_ID , DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES e JOIN DEPARTMENTS D 
USING (DEPARTMENT_id) JOIN LOCATIONS l 
USING (LOCATION_id)
WHERE location_id = 2500;

-- 커미션을 버는 모든 사람들의 성, 부서명, 지역 ID 및 도시 명을 조회하세요
SELECT FIRST_NAME , DEPARTMENT_NAME, location_id, CITY
FROM EMPLOYEES e JOIN DEPARTMENTS D 
USING (DEPARTMENT_id) JOIN LOCATIONS l 
USING (LOCATION_id)
WHERE COMMISSION_PCT IS NOT NULL;

-- 시애틀에 사는 사람 중 커미션을 버는 모든 사람들의 성, 부서명, 지역 ID 및 도시 명을 조회하세요
SELECT FIRST_NAME , DEPARTMENT_NAME, location_id, CITY
FROM EMPLOYEES e JOIN DEPARTMENTS D 
USING (DEPARTMENT_id) JOIN LOCATIONS l 
USING (LOCATION_id)
WHERE city = 'seattle' AND
		COMMISSION_PCT IS NOT NULL;

-- 사원이 없는 부서를 조회하세요
SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES; -- 사원이 있는 부서 : 11

SELECT DEPARTMENT_ID 
FROM DEPARTMENTS -- 전 부서 : 27
	
SELECT DEPARTMENT_ID, EMPLOYEE_ID
FROM EMPLOYEES e right OUTER JOIN DEPARTMENTS d
USING (DEPARTMENT_id)
WHERE EMPLOYEE_ID IS NULL; -- 16개 부서에서 사원 없음

-- 각 사원을 관리하는 상사의 이름을 조회하세요
SELECT e.EMPLOYEE_ID 사원번호, e.FIRST_NAME 사원이름, e.MANAGER_ID 상사번호,
		m.EMPLOYEE_ID 상사의사번, m.FIRST_NAME 상사이름
FROM EMPLOYEES e JOIN EMPLOYEES m
ON e.MANAGER_ID = m.EMPLOYEE_ID
ORDER BY 사원번호;

-- 사원이름과 그 사원의 관리자 이름을 조회하세요
SELECT e.FIRST_NAME 사원이름, m.FIRST_NAME 상사이름
FROM EMPLOYEES e JOIN EMPLOYEES m
ON e.MANAGER_ID = m.EMPLOYEE_ID
ORDER BY 사원이름;

-- ACCOUNTING 부서 소속 사원의 이름과 입사일 조회하세요
SELECT FIRST_NAME, HIRE_DATE
FROM EMPLOYEES e JOIN DEPARTMENTS d 
USING (department_id)
WHERE DEPARTMENT_NAME = 'Accounting';

-- 이름에 A가 들어가는 사원들의 이름과 부서이름을 조회하세요
SELECT FIRST_NAME, DEPARTMENT_name
FROM EMPLOYEES e JOIN DEPARTMENTS d 
USING (department_id)
WHERE FIRST_NAME LIKE '%A%'OR
		FIRST_NAME LIKE '%a%';

-- 연봉이 3000 이상인 사원의 이름과 부서명과 연봉을 조회하세요
SELECT FIRST_NAME , DEPARTMENT_ID, SALARY  
FROM EMPLOYEES e JOIN DEPARTMENTS d 
USING (DEPARTMENT_id)
WHERE SALARY >= 3000
ORDER BY SALARY desc;

-- 급여가 3000에서 5000사이인 사원의 이름과 소속부서명 조회하세요
SELECT FIRST_NAME , DEPARTMENT_ID, SALARY  
FROM EMPLOYEES e JOIN DEPARTMENTS d 
USING (DEPARTMENT_id)
WHERE SALARY between 3000 AND 5000
ORDER BY SALARY desc;

-- 급여가 3000이하인 사원의 이름과 급여, 근무지를 조회하세요
SELECT FIRST_NAME , DEPARTMENT_ID, city, SALARY  
FROM EMPLOYEES e JOIN DEPARTMENTS d 
USING (DEPARTMENT_id) JOIN LOCATIONS l
USING (LOCATION_id)
WHERE SALARY <= 3000
ORDER BY SALARY desc;

-- TJ 이란 사원보다 늦게 입사한 사원의 이름과 입사일, 부서번호를 조회하세요
-- catesian product, cross join이용
SELECT tj.FIRST_NAME TJ, tj.HIRE_DATE TJ입사일,
		e.FIRST_NAME 사원이름,
		e.HIRE_DATE 사원입사일,
		e.DEPARTMENT_ID 사원부서번호
FROM EMPLOYEES tj, EMPLOYEES e
WHERE tj.FIRST_NAME = 'TJ'
	AND tj.hire_date < e.hire_date;

SELECT tj.FIRST_NAME TJ, tj.HIRE_DATE TJ입사일,
		e.FIRST_NAME 사원이름,
		e.HIRE_DATE 사원입사일,
		e.DEPARTMENT_ID 사원부서번호
FROM EMPLOYEES tj CROSS join EMPLOYEES e
WHERE tj.FIRST_NAME = 'TJ'
	AND tj.hire_date < e.hire_date;

====

-- 직무를 전환한 이력이 없는 사원의 모든 정보를 조회
SELECT DISTINCT EMPLOYEE_ID  FROM JOB_HISTORY;

-- 서브쿼리
SELECT * FROM EMPLOYEES
WHERE EMPLOYEE_ID NOT IN
(SELECT DISTINCT EMPLOYEE_ID FROM JOB_HISTORY);

-- outer join
SELECT * 
FROM EMPLOYEES e LEFT OUTER JOIN JOB_HISTORY jh
USING (EMPLOYEE_ID)
WHERE start_date IS NULL;

-- 150번 사원보다 늦게 입사한 사원 중
-- 150번 사원보다 더 많은 연봉을 받는 사원을 조회하라.

SELECT HIRE_DATE FROM EMPLOYEES
WHERE EMPLOYEE_ID = 150; -- 2005-01-30

SELECT SALARY FROM EMPLOYEES
WHERE EMPLOYEE_ID = 150; -- 10000

SELECT HIRE_DATE, SALARY  FROM EMPLOYEES
WHERE EMPLOYEE_ID = 150;

-- 다중컬럼 하위질의는 in만 사용가능
SELECT * FROM EMPLOYEES
WHERE (HIRE_DATE,SALARY) > (SELECT HIRE_DATE,SALARY FROM EMPLOYEES
WHERE EMPLOYEE_ID = 150);


SELECT * FROM EMPLOYEES
WHERE HIRE_DATE > (SELECT HIRE_DATE FROM EMPLOYEES
WHERE EMPLOYEE_ID = 150) AND SALARY > (SELECT SALARY FROM EMPLOYEES
WHERE EMPLOYEE_ID = 150);

-- 담당 직무의 최대 연봉을 받고 있는 사원들의 모든 정보를 조회하라.
SELECT DISTINCT (JOB_ID),MAX(SALARY) SALARY
FROM EMPLOYEES
GROUP BY JOB_ID;

-- 하위질의문에서 제공하는 값이 2가지일때
-- 다중컬럼 하위질의를 사용하면 됨
SELECT FIRST_NAME, JOB_ID, SALARY  FROM EMPLOYEES 
WHERE (JOB_ID, SALARY) in
(SELECT JOB_ID, MAX(SALARY) SALARY
FROM EMPLOYEES
GROUP BY JOB_ID);

-- 사원수가 가장 많은 도시에서 근무하는 모든 사원들의
-- 연봉 총합을 조회하라.

-- oracle에서 top n 함수 구현하기
-- 상위 n개 행 출력하기
-- select * from (인라인뷰) where rownum <= n (11g)
-- SELECT * from 테이블명 fetch first n row only (12c)

-- 인라인뷰
-- 하위질의문을 from 절에 사용할 경우
-- 하위질의문 못지않게 인라인뷰도 자주 사용

SELECT sum(SALARY) 연봉총합
	FROM EMPLOYEES e JOIN DEPARTMENTS d
	USING (DEPARTMENT_id) JOIN LOCATIONS l 
	USING (LOCATION_id)
WHERE city =
(SELECT city 도시 from
	(SELECT city 도시, count(EMPLOYEE_ID) 사원수
	FROM EMPLOYEES e JOIN DEPARTMENTS d
	USING (DEPARTMENT_id) JOIN LOCATIONS l 
	USING (LOCATION_id)
	GROUP BY city ORDER BY 사원수 DESC)
	where rownum <= 1);

SELECT * FROM 
(SELECT city 도시, count(EMPLOYEE_ID) 사원수
FROM EMPLOYEES e JOIN DEPARTMENTS d
USING (DEPARTMENT_id) JOIN LOCATIONS l 
USING (LOCATION_id)
GROUP BY city ORDER BY 사원수 DESC)
where rownum <= 1;

SELECT city 도시, count(EMPLOYEE_ID) 사원수
FROM EMPLOYEES e JOIN DEPARTMENTS d
USING (DEPARTMENT_id) JOIN LOCATIONS l 
USING (LOCATION_id)
GROUP BY city ORDER BY 사원수 DESC;

-- 입사일이 가장 오래된 사원을 조회하라.
SELECT min(HIRE_DATE) FROM EMPLOYEES;

SELECT FIRST_NAME, JOB_ID
FROM EMPLOYEES
WHERE HIRE_DATE =
	(SELECT min(HIRE_DATE) FROM EMPLOYEES);






